{
    "@graph": [
        {
            "@id": "gnd:1068096934",
            "sameAs": "Universit\u00e4tsverlag Potsdam"
        },
        {
            "@id": "gnd:1069348694",
            "sameAs": "Schneider, Sven"
        },
        {
            "@id": "gnd:131769251",
            "sameAs": "Lambers, Leen"
        },
        {
            "@id": "gnd:4006650-2",
            "sameAs": "Bildung"
        },
        {
            "@id": "gnd:4053474-1",
            "sameAs": "Schule"
        },
        {
            "@id": "gnd:4123065-6",
            "sameAs": "Digitalisierung"
        },
        {
            "@id": "gnd:7623494-0",
            "sameAs": "Cloud Computing"
        },
        {
            "@id": "https://www.tib.eu/de/suchen/id/TIBKAT%3A168899274X",
            "@type": "bibo:Report",
            "P1053": "Online-Ressource (34 Seiten, 1805 KB)",
            "creator": "Orejas, Fernando",
            "description": "Diagramme",
            "identifier": [
                "(doi)10.25932/publishup-42751",
                "(firstid)KXP:168899274X",
                "(ppn)168899274X",
                "(isbn13)9783869564623"
            ],
            "publisher": "Universit\u00e4tsverlag Potsdam",
            "subject": [
                "(classificationName=bk, id=10640623X)54.32 - Rechnerkommunikation",
                "(classificationName=linseach:mapping)inf"
            ],
            "title": "A logic-based incremental approach to graph repair",
            "abstract": [
                "Graph repair, restoring consistency of a graph, plays a prominent role in several areas of computer science and beyond: For example, in model-driven engineering, the abstract syntax of models is usually encoded using graphs. Flexible edit operations temporarily create inconsistent graphs not representing a valid model, thus requiring graph repair. Similarly, in graph databases\u2014managing the storage and manipulation of graph data\u2014updates may cause that a given database does not satisfy some integrity constraints, requiring also graph repair. We present a logic-based incremental approach to graph repair, generating a sound and complete (upon termination) overview of least-changing repairs. In our context, we formalize consistency by so-called graph conditions being equivalent to first-order logic on graphs. We present two kind of repair algorithms: State-based repair restores consistency independent of the graph update history, whereas deltabased (or incremental) repair takes this history explicitly into account. Technically, our algorithms rely on an existing model generation algorithm for graph conditions implemented in AutoGraph. Moreover, the delta-based approach uses the new concept of satisfaction (ST) trees for encoding if and how a graph satisfies a graph condition. We then demonstrate how to manipulate these STs incrementally with respect to a graph update.Die Reparatur von Graphen, die Wiederherstellung der Konsistenz eines Graphen, spielt in mehreren Bereichen der Informatik und dar\u00fcber hinaus eine herausragende Rolle: Beispielsweise wird in der modellgetriebenen Konstruktion die abstrakte Syntax von Modellen in der Regel mithilfe von Graphen kodiert. Flexible Bearbeitungsvorg\u00e4nge erstellen vor\u00fcbergehend inkonsistente Diagramme, die kein g\u00fcltiges Modell darstellen, und erfordern daher eine Reparatur des Diagramms. Auf \u00e4hnliche Weise k\u00f6nnen Aktualisierungen in Graphendatenbanken - die das Speichern und Bearbeiten von Graphendaten verwalten - dazu f\u00fchren, dass eine bestimmte Datenbank einige Integrit\u00e4tsbeschr\u00e4nkungen nicht erf\u00fcllt und auch eine Graphreparatur erforderlich macht.",
                "ir pr\u00e4sentieren einen logikbasierten inkrementellen Ansatz f\u00fcr die Graphreparatur, der eine solide und vollst\u00e4ndige (nach Beendigung) \u00dcbersicht \u00fcber die am wenigsten ver\u00e4ndernden Reparaturen erstellt. In unserem Kontext formalisieren wir die Konsistenz mittels sogenannten Graphbedingungen die der Logik erster Ordnung in Graphen entsprechen. Wir stellen zwei Arten von Reparaturalgorithmen vor: Die zustandsbasierte Reparatur stellt die Konsistenz unabh\u00e4ngig vom Verlauf der Graph\u00e4nderung wieder her, w\u00e4hrend die deltabasierte (oder inkrementelle) Reparatur diesen Verlauf explizit ber\u00fccksichtigt. Technisch st\u00fctzen sich unsere Algorithmen auf einen vorhandenen Modellgenerierungsalgorithmus f\u00fcr in AutoGraph implementierte Graphbedingungen. Dar\u00fcber hinaus verwendet der deltabasierte Ansatz das neue Konzept der Erf\u00fcllungsb\u00e4ume (STs) zum Kodieren, ob und wie ein Graph eine Graphbedingung erf\u00fcllt. Wir zeigen dann, wie diese STs in Bezug auf eine Graphaktualisierung inkrementell manipuliert werden."
            ],
            "contributor": "Technische Informationsbibliothek (TIB)",
            "dcterms:creator": [
                {
                    "@id": "gnd:131769251"
                },
                {
                    "@id": "gnd:1069348694"
                },
                {
                    "@id": "gnd:1068096934"
                }
            ],
            "issued": "2019",
            "language": "http://id.loc.gov/vocabulary/iso639-1/de",
            "license": "open access",
            "medium": "rda:termList/RDACarrierType/1018",
            "dcterms:subject": [
                {
                    "@id": "gnd:4053474-1"
                },
                {
                    "@id": "gnd:7623494-0"
                },
                {
                    "@id": "gnd:4123065-6"
                },
                {
                    "@id": "gnd:4006650-2"
                }
            ],
            "volume": "Nr. 126",
            "isLike": "doi:10.25932/publishup-42751",
            "P30128": "Technische Berichte des Hasso-Plattner-Instituts f\u00fcr Digital Engineering an der Universit\u00e4t Potsdam",
            "P60163": "Potsdam"
        }
    ],
    "@id": "urn:x-arq:DefaultGraphNode",
    "@context": {
        "sameAs": "http://www.w3.org/2002/07/owl#sameAs",
        "identifier": "http://purl.org/dc/elements/1.1/identifier",
        "creator": "http://purl.org/dc/elements/1.1/creator",
        "publisher": "http://purl.org/dc/elements/1.1/publisher",
        "issued": "http://purl.org/dc/terms/issued",
        "P30128": "http://www.rdaregistry.info/Elements/m/#P30128",
        "medium": {
            "@id": "http://purl.org/dc/terms/medium",
            "@type": "@id"
        },
        "P60163": "http://www.rdaregistry.info/Elements/u/#P60163",
        "abstract": "http://purl.org/dc/terms/abstract",
        "title": "http://purl.org/dc/elements/1.1/title",
        "contributor": "http://purl.org/dc/terms/contributor",
        "subject": "http://purl.org/dc/elements/1.1/subject",
        "description": "http://purl.org/dc/elements/1.1/description",
        "volume": "http://purl.org/ontology/bibo/volume",
        "P1053": "http://iflastandards.info/ns/isbd/elements/P1053",
        "language": {
            "@id": "http://purl.org/dc/terms/language",
            "@type": "@id"
        },
        "license": "http://purl.org/dc/terms/license",
        "isLike": {
            "@id": "http://umbel.org/umbel#isLike",
            "@type": "@id"
        },
        "umbel": "http://umbel.org/umbel#",
        "rdau": "http://www.rdaregistry.info/Elements/u/#",
        "owl": "http://www.w3.org/2002/07/owl#",
        "dcterms": "http://purl.org/dc/terms/",
        "bibo": "http://purl.org/ontology/bibo/",
        "rdam": "http://www.rdaregistry.info/Elements/m/#",
        "gnd": "http://d-nb.info/gnd/",
        "isbd": "http://iflastandards.info/ns/isbd/elements/",
        "rda": "http://rdvocab.info/",
        "doi": "https://doi.org/"
    }
}