{
    "@graph": [
        {
            "@id": "gnd:1209551411",
            "sameAs": "Nutz, Alexander"
        },
        {
            "@id": "gnd:4055382-6",
            "sameAs": "Software"
        },
        {
            "@id": "gnd:4076370-5",
            "sameAs": "Programmierung"
        },
        {
            "@id": "gnd:4135577-5",
            "sameAs": "Verifikation"
        },
        {
            "@id": "gnd:4506115-4",
            "sameAs": "Formaler Beweis"
        },
        {
            "@id": "https://www.tib.eu/de/suchen/id/TIBKAT%3A169816839X",
            "@type": "bibo:Thesis",
            "P1053": "1 Online-Ressource (vii, 105 Seiten)",
            "identifier": [
                "(ppn)169816839X",
                "(contract)FRUB-opus-165473",
                "(firstid)KXP:169816839X",
                "(doi)10.6094/UNIFR/165473"
            ],
            "http://purl.org/dc/elements/1.1/subject": [
                "(classificationName=linseach:mapping)inf",
                "(classificationName=ddc)005.14",
                "(classificationName=ddc-dbn)004"
            ],
            "title": "Data flow in program verification",
            "abstract": [
                "Abstract: Gegenstand dieser Arbeit ist die theoretische und praktische Untersuchung von  Techniken, die die Verfikation von Programmen unterstützen sollen. Den vorge-  stellten Techniken gemeinsam ist, dass ihnen das Konzept des Datenflusses zu-  grundeliegt. Zwischen Programmbefehl s und Programmbefehl s&apos; besteht ein Da-  tenfluss, wenn s einen Wert in den Speicher schreibt, den s&apos; verwendet (also aus  dem Speicher liest). Dieses Konzept legt eine bestimmte Sicht auf das zu verifizie-  rende Programm nahe. Wenn man zum Beispiel herausfinden will, welche Werte  eine bestimmte Variable in einem bestimmten Programmbefehl annehmen kann,  dann scheint es natürlich, alle eingehenden Datenflüsse zurückzuverfolgen, um her-  auszufinden, mit welchen Werte die Variable geschrieben worden sein kann. Diese  Werte können ihrerseits wiederum von anderen Variablen abhängen, sodass weite-  re Datenflüsse zurückverfolgt werden müssen, bis alle möglichen Werte ermittelt  werden können.  Es gibt ein breites Spektrum von Möglichkeiten, diese Sicht auf Programme  zu deren Verifikation einzusetzen. Die folgenden drei Fragen bilden einen Auszug  aus diesem Spektrum: 1. Ein Analogon zu klassischen Floyd-Beweisen sind Daten-  flussbeweise. Was sind die Vor- und Nachteile von Datenflussbeweisen? 2. Durch  die Anwesenheit von Arrays im Programm wird es deutlich schwieriger, eine gu-  te Charakterisierung der im Programm möglichen Datenflüsse zu ermitteln. Gibt  es eine abstrakte Domäne (im Sinne der abstrakten Interpretation von Program-  men), die gut skaliert und mächtig genug ist, um eine nützliche Approximation  der Datenflüsse in einem Programm mit Arrays herzuleiten? 3. Die Abwesenheit  von bestimmten Datenflüssen in einem gegebenen Programm mit Arrays (und die  daraus resultierende Unabhängigkeit der zugehörigen Programmbefehle) ist häufig  ein wichtiger und schwer zu inferierender Bestandteil des Korrektheitsbeweises des  Programms. Ist es möglich eine Programmtransformation zu entwerfen, die diese  Information (über die Abwesenheit von Datenflüssen) in das transformierte Pro-  gramm enkodiert, sodass die anschließende Verifikation des Programms diese Be-  weisaufgaben nicht mehr zu erledigen braucht? Diese drei Fragen sollen in dieser  Arbeit beantwortet werden",
                "Abstract: We present several techniques and insights that aid program verification. The common theme of these techniques and insights is their relation to the notion of data flow. Intuitively, there is a data flow from program statement s to program statement s&apos; if s writes a value (to memory) that s&apos; uses (reads from memory). This notion induces a particular view on a program that is to be verified. For example, when we want to find out which values a certain variable in a certain statement can assume in a program, it is natural to check all the incoming data flows for that variable in that statement and see which values they provide. Of course, the provided values may depend on other data flows and so on. There is a wide variety of ways to apply this view on programs in program verification. For this thesis, we picked the following three questions. 1. The analogue to classical Floyd proofs in the data flow view are data flow proofs. What is their potential and what are their limitations? 2. Data flow becomes much more complex in the presence of arrays. Can we develop a scalable abstract domain that is powerful enough to find a good approximation of the data flow relationships in a program with arrays? 3. The absence of data flows in a program with arrays (i.e., the independence of certain statements) is often an essential and difficult part of the program’s correctness proof. Can we give a program transformation that encodes this information into the transformed program in order to relieve some backend-verifier of these proof tasks? In this thesis we will give answers to these three questions"
            ],
            "contributor": "Technische Informationsbibliothek (TIB)",
            "creator": "gnd:1209551411",
            "isPartOf": "(collectioncode)GBV-ODiss",
            "issued": "2019",
            "language": "http://id.loc.gov/vocabulary/iso639-1/en",
            "license": "open access",
            "medium": "rda:termList/RDACarrierType/1018",
            "subject": [
                "gnd:4076370-5",
                "gnd:4506115-4",
                "gnd:4055382-6",
                "gnd:4135577-5"
            ],
            "isLike": "doi:10.6094/UNIFR/165473",
            "P60163": "Freiburg"
        }
    ],
    "@id": "urn:x-arq:DefaultGraphNode",
    "@context": {
        "creator": {
            "@id": "http://purl.org/dc/terms/creator",
            "@type": "@id"
        },
        "language": {
            "@id": "http://purl.org/dc/terms/language",
            "@type": "@id"
        },
        "identifier": "http://purl.org/dc/elements/1.1/identifier",
        "issued": "http://purl.org/dc/terms/issued",
        "subject": {
            "@id": "http://purl.org/dc/terms/subject",
            "@type": "@id"
        },
        "P1053": "http://iflastandards.info/ns/isbd/elements/P1053",
        "P60163": "http://www.rdaregistry.info/Elements/u/#P60163",
        "title": "http://purl.org/dc/elements/1.1/title",
        "medium": {
            "@id": "http://purl.org/dc/terms/medium",
            "@type": "@id"
        },
        "contributor": "http://purl.org/dc/terms/contributor",
        "isLike": {
            "@id": "http://umbel.org/umbel#isLike",
            "@type": "@id"
        },
        "abstract": "http://purl.org/dc/terms/abstract",
        "isPartOf": "http://purl.org/dc/terms/isPartOf",
        "license": "http://purl.org/dc/terms/license",
        "sameAs": "http://www.w3.org/2002/07/owl#sameAs",
        "umbel": "http://umbel.org/umbel#",
        "rdau": "http://www.rdaregistry.info/Elements/u/#",
        "owl": "http://www.w3.org/2002/07/owl#",
        "dcterms": "http://purl.org/dc/terms/",
        "bibo": "http://purl.org/ontology/bibo/",
        "rdam": "http://www.rdaregistry.info/Elements/m/#",
        "gnd": "http://d-nb.info/gnd/",
        "isbd": "http://iflastandards.info/ns/isbd/elements/",
        "rda": "http://rdvocab.info/",
        "doi": "https://doi.org/"
    }
}