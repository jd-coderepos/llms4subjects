{
    "@graph": [
        {
            "@id": "gnd:1068096934",
            "sameAs": "Universit\u00e4tsverlag Potsdam"
        },
        {
            "@id": "gnd:1069348694",
            "sameAs": "Schneider, Sven"
        },
        {
            "@id": "gnd:1143617126",
            "sameAs": "Maximova, Maria"
        },
        {
            "@id": "gnd:1168635489",
            "sameAs": "Sakizloglou, Lucas"
        },
        {
            "@id": "gnd:173277950",
            "sameAs": "Giese, Holger"
        },
        {
            "@id": "gnd:4006650-2",
            "sameAs": "Bildung"
        },
        {
            "@id": "gnd:4123065-6",
            "sameAs": "Digitalisierung"
        },
        {
            "@id": "gnd:7623494-0",
            "sameAs": "Cloud Computing"
        },
        {
            "@id": "https://www.tib.eu/de/suchen/id/TIBKAT%3A1688997199",
            "@type": "bibo:Report",
            "P1053": "Online-Ressource (34 Seiten, 1760 KB)",
            "description": "Diagramme",
            "identifier": [
                "(firstid)KXP:1688997199",
                "(isbn13)9783869564630",
                "(ppn)1688997199",
                "(doi)10.25932/publishup-42752"
            ],
            "publisher": "Universit\u00e4tsverlag Potsdam",
            "subject": [
                "(classificationName=linseach:mapping)inf",
                "(classificationName=bk, id=10640623X)54.32 - Rechnerkommunikation"
            ],
            "title": "Metric temporal graph logic over typed attributed graphs",
            "abstract": [
                "Graph repair, restoring consistency of a graph, plays a prominent role in several areas of computer science and beyond: For example, in model-driven engineering, the abstract syntax of models is usually encoded using graphs. Flexible edit operations temporarily create inconsistent graphs not representing a valid model, thus requiring graph repair. Similarly, in graph databases\u2014managing the storage and manipulation of graph data\u2014updates may cause that a given database does not satisfy some integrity constraints, requiring also graph repair. We present a logic-based incremental approach to graph repair, generating a sound and complete (upon termination) overview of least-changing repairs. In our context, we formalize consistency by so-called graph conditions being equivalent to first-order logic on graphs. We present two kind of repair algorithms: State-based repair restores consistency independent of the graph update history, whereas deltabased (or incremental) repair takes this history explicitly into account. Technically, our algorithms rely on an existing model generation algorithm for graph conditions implemented in AutoGraph. Moreover, the delta-based approach uses the new concept of satisfaction (ST) trees for encoding if and how a graph satisfies a graph condition. We then demonstrate how to manipulate these STs incrementally with respect to a graph update. Verschiedene Arten typisierter attributierter Graphen k\u00f6nnen verwendet werden, um Systemzust\u00e4nde aus einem breiten Bereich von Dom\u00e4nen darzustellen. F\u00fcr dynamische Systeme k\u00f6nnen etablierte Formalismen wie die Graphtransformation ein formales Modell f\u00fcr die Definition von Zustandssequenzen liefern. Wir betrachten den Fall, in dem zwischen Zustands\u00e4nderungen Zeit vergehen kann, und f\u00fchren eine Logik ein, die als Metric Temporal Graph Logic (MTGL) bezeichnet wird, um \u00fcber solche zeitgesteuerten Graphsequenzen zu urteilen. Mit dieser Logik dr\u00fccken wir Eigenschaften der Struktur und der Attribute von Zust\u00e4nden sowie des Auftretens von Zust\u00e4nden \u00fcber die Zeit aus, die durch ihre innere Struktur miteinander verbunden sind, was bisher keine formale Logik \u00fcber Graphen pr\u00e4zise bewerkstelligt. Erstens, basierend auf zeitgesteuerten Graphsequenzen als Modelle f\u00fcr die Systemevolution, definieren wir MTGL, indem wir den zeitlichen Operator bis zu einer gewissen Zeitgrenze in die etablierte Logik von (verschachtelten) Graphbedingungen integrieren. Zweitens skizzieren wir, wie eine endliche zeitgesteuerte Diagrammsequenz als einzelnes Diagramm dargestellt werden kann, das alle zeitlichen \u00c4nderungen enth\u00e4lt (als Diagramm mit Verlauf bezeichnet), wie die Erf\u00fcllung von MTGL-Bedingungen f\u00fcr ein solches Diagramm definiert werden kann, und zeigen, dass beide Darstellungen dieselben MTGL-Bedingungen erf\u00fcllen. Drittens zeigen wir, wie MTGL-Bedingungen auf (verschachtelte) Diagrammbedingungen reduziert werden k\u00f6nnen, und zeigen anhand dieser Reduzierung, dass beide zugrunde liegenden Logiken gleicherma\u00dfen aussagekr\u00e4ftig sind. Schlie\u00dflich stellen wir eine Erweiterung des Tools AutoGraph vor, mit der die Erf\u00fcllung der MTGL-Bedingungen f\u00fcr zeitgesteuerte Diagrammsequenzen \u00fcberpr\u00fcft werden kann, indem die Erf\u00fcllung der (verschachtelten) Diagrammbedingungen \u00fcberpr\u00fcft wird, die unter Verwendung der vorgeschlagenen Reduzierung f\u00fcr das Diagramm mit dem Verlauf entsprechend dem zeitgesteuerten Diagramm erhalten wurden.",
                "Graph repair, restoring consistency of a graph, plays a prominent role in several areas of computer science and beyond: For example, in model-driven engineering, the abstract syntax of models is usually encoded using graphs. Flexible edit operations temporarily create inconsistent graphs not representing a valid model, thus requiring graph repair. Similarly, in graph databases\u2014managing the storage and manipulation of graph data\u2014updates may cause that a given database does not satisfy some integrity constraints, requiring also graph repair. We present a logic-based incremental approach to graph repair, generating a sound and complete (upon termination) overview of least-changing repairs. In our context, we formalize consistency by so-called graph conditions being equivalent to first-order logic on graphs. We present two kind of repair algorithms: State-based repair restores consistency independent of the graph update history, whereas deltabased (or incremental) repair takes this history explicitly into account. Technically, our algorithms rely on an existing model generation algorithm for graph conditions implemented in AutoGraph. Moreover, the delta-based approach uses the new concept of satisfaction (ST) trees for encoding if and how a graph satisfies a graph condition. We then demonstrate how to manipulate these STs incrementally with respect to a graph update."
            ],
            "contributor": "Technische Informationsbibliothek (TIB)",
            "creator": [
                "gnd:1143617126",
                "gnd:1168635489",
                "gnd:173277950",
                "gnd:1068096934",
                "gnd:1069348694"
            ],
            "issued": "2019",
            "language": "http://id.loc.gov/vocabulary/iso639-1/de",
            "license": "open access",
            "medium": "rda:termList/RDACarrierType/1018",
            "dcterms:subject": [
                {
                    "@id": "gnd:4006650-2"
                },
                {
                    "@id": "gnd:4123065-6"
                },
                {
                    "@id": "gnd:7623494-0"
                }
            ],
            "volume": "Nr. 127",
            "isLike": "doi:10.25932/publishup-42752",
            "P30128": "Technische Berichte des Hasso-Plattner-Instituts f\u00fcr Digital Engineering an der Universit\u00e4t Potsdam",
            "P60163": "Potsdam"
        }
    ],
    "@id": "urn:x-arq:DefaultGraphNode",
    "@context": {
        "sameAs": "http://www.w3.org/2002/07/owl#sameAs",
        "P1053": "http://iflastandards.info/ns/isbd/elements/P1053",
        "creator": {
            "@id": "http://purl.org/dc/terms/creator",
            "@type": "@id"
        },
        "identifier": "http://purl.org/dc/elements/1.1/identifier",
        "volume": "http://purl.org/ontology/bibo/volume",
        "language": {
            "@id": "http://purl.org/dc/terms/language",
            "@type": "@id"
        },
        "license": "http://purl.org/dc/terms/license",
        "subject": "http://purl.org/dc/elements/1.1/subject",
        "contributor": "http://purl.org/dc/terms/contributor",
        "P30128": "http://www.rdaregistry.info/Elements/m/#P30128",
        "abstract": "http://purl.org/dc/terms/abstract",
        "description": "http://purl.org/dc/elements/1.1/description",
        "P60163": "http://www.rdaregistry.info/Elements/u/#P60163",
        "isLike": {
            "@id": "http://umbel.org/umbel#isLike",
            "@type": "@id"
        },
        "title": "http://purl.org/dc/elements/1.1/title",
        "medium": {
            "@id": "http://purl.org/dc/terms/medium",
            "@type": "@id"
        },
        "issued": "http://purl.org/dc/terms/issued",
        "publisher": "http://purl.org/dc/elements/1.1/publisher",
        "umbel": "http://umbel.org/umbel#",
        "rdau": "http://www.rdaregistry.info/Elements/u/#",
        "owl": "http://www.w3.org/2002/07/owl#",
        "dcterms": "http://purl.org/dc/terms/",
        "bibo": "http://purl.org/ontology/bibo/",
        "rdam": "http://www.rdaregistry.info/Elements/m/#",
        "gnd": "http://d-nb.info/gnd/",
        "isbd": "http://iflastandards.info/ns/isbd/elements/",
        "rda": "http://rdvocab.info/",
        "doi": "https://doi.org/"
    }
}